// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package formal

import (
	"context"
	"reflect"

	"errors"
	"github.com/formalco/pulumi-formal/sdk/go/formal/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Registering a Connector Listener Rule with Formal.
type ConnectorListenerRule struct {
	pulumi.CustomResourceState

	// The ID of the listener this rule is associated with.
	ConnectorListenerId pulumi.StringOutput `pulumi:"connectorListenerId"`
	// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
	Rule pulumi.StringOutput `pulumi:"rule"`
	// If set to true, this connector listener rule cannot be deleted.
	TerminationProtection pulumi.BoolPtrOutput `pulumi:"terminationProtection"`
	// The type of the rule. It can be either `any`, `resource` or `technology`
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewConnectorListenerRule registers a new resource with the given unique name, arguments, and options.
func NewConnectorListenerRule(ctx *pulumi.Context,
	name string, args *ConnectorListenerRuleArgs, opts ...pulumi.ResourceOption) (*ConnectorListenerRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectorListenerId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectorListenerId'")
	}
	if args.Rule == nil {
		return nil, errors.New("invalid value for required argument 'Rule'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ConnectorListenerRule
	err := ctx.RegisterResource("formal:index/connectorListenerRule:ConnectorListenerRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConnectorListenerRule gets an existing ConnectorListenerRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConnectorListenerRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConnectorListenerRuleState, opts ...pulumi.ResourceOption) (*ConnectorListenerRule, error) {
	var resource ConnectorListenerRule
	err := ctx.ReadResource("formal:index/connectorListenerRule:ConnectorListenerRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ConnectorListenerRule resources.
type connectorListenerRuleState struct {
	// The ID of the listener this rule is associated with.
	ConnectorListenerId *string `pulumi:"connectorListenerId"`
	// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
	Rule *string `pulumi:"rule"`
	// If set to true, this connector listener rule cannot be deleted.
	TerminationProtection *bool `pulumi:"terminationProtection"`
	// The type of the rule. It can be either `any`, `resource` or `technology`
	Type *string `pulumi:"type"`
}

type ConnectorListenerRuleState struct {
	// The ID of the listener this rule is associated with.
	ConnectorListenerId pulumi.StringPtrInput
	// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
	Rule pulumi.StringPtrInput
	// If set to true, this connector listener rule cannot be deleted.
	TerminationProtection pulumi.BoolPtrInput
	// The type of the rule. It can be either `any`, `resource` or `technology`
	Type pulumi.StringPtrInput
}

func (ConnectorListenerRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*connectorListenerRuleState)(nil)).Elem()
}

type connectorListenerRuleArgs struct {
	// The ID of the listener this rule is associated with.
	ConnectorListenerId string `pulumi:"connectorListenerId"`
	// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
	Rule string `pulumi:"rule"`
	// If set to true, this connector listener rule cannot be deleted.
	TerminationProtection *bool `pulumi:"terminationProtection"`
	// The type of the rule. It can be either `any`, `resource` or `technology`
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a ConnectorListenerRule resource.
type ConnectorListenerRuleArgs struct {
	// The ID of the listener this rule is associated with.
	ConnectorListenerId pulumi.StringInput
	// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
	Rule pulumi.StringInput
	// If set to true, this connector listener rule cannot be deleted.
	TerminationProtection pulumi.BoolPtrInput
	// The type of the rule. It can be either `any`, `resource` or `technology`
	Type pulumi.StringInput
}

func (ConnectorListenerRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*connectorListenerRuleArgs)(nil)).Elem()
}

type ConnectorListenerRuleInput interface {
	pulumi.Input

	ToConnectorListenerRuleOutput() ConnectorListenerRuleOutput
	ToConnectorListenerRuleOutputWithContext(ctx context.Context) ConnectorListenerRuleOutput
}

func (*ConnectorListenerRule) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorListenerRule)(nil)).Elem()
}

func (i *ConnectorListenerRule) ToConnectorListenerRuleOutput() ConnectorListenerRuleOutput {
	return i.ToConnectorListenerRuleOutputWithContext(context.Background())
}

func (i *ConnectorListenerRule) ToConnectorListenerRuleOutputWithContext(ctx context.Context) ConnectorListenerRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorListenerRuleOutput)
}

// ConnectorListenerRuleArrayInput is an input type that accepts ConnectorListenerRuleArray and ConnectorListenerRuleArrayOutput values.
// You can construct a concrete instance of `ConnectorListenerRuleArrayInput` via:
//
//	ConnectorListenerRuleArray{ ConnectorListenerRuleArgs{...} }
type ConnectorListenerRuleArrayInput interface {
	pulumi.Input

	ToConnectorListenerRuleArrayOutput() ConnectorListenerRuleArrayOutput
	ToConnectorListenerRuleArrayOutputWithContext(context.Context) ConnectorListenerRuleArrayOutput
}

type ConnectorListenerRuleArray []ConnectorListenerRuleInput

func (ConnectorListenerRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectorListenerRule)(nil)).Elem()
}

func (i ConnectorListenerRuleArray) ToConnectorListenerRuleArrayOutput() ConnectorListenerRuleArrayOutput {
	return i.ToConnectorListenerRuleArrayOutputWithContext(context.Background())
}

func (i ConnectorListenerRuleArray) ToConnectorListenerRuleArrayOutputWithContext(ctx context.Context) ConnectorListenerRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorListenerRuleArrayOutput)
}

// ConnectorListenerRuleMapInput is an input type that accepts ConnectorListenerRuleMap and ConnectorListenerRuleMapOutput values.
// You can construct a concrete instance of `ConnectorListenerRuleMapInput` via:
//
//	ConnectorListenerRuleMap{ "key": ConnectorListenerRuleArgs{...} }
type ConnectorListenerRuleMapInput interface {
	pulumi.Input

	ToConnectorListenerRuleMapOutput() ConnectorListenerRuleMapOutput
	ToConnectorListenerRuleMapOutputWithContext(context.Context) ConnectorListenerRuleMapOutput
}

type ConnectorListenerRuleMap map[string]ConnectorListenerRuleInput

func (ConnectorListenerRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectorListenerRule)(nil)).Elem()
}

func (i ConnectorListenerRuleMap) ToConnectorListenerRuleMapOutput() ConnectorListenerRuleMapOutput {
	return i.ToConnectorListenerRuleMapOutputWithContext(context.Background())
}

func (i ConnectorListenerRuleMap) ToConnectorListenerRuleMapOutputWithContext(ctx context.Context) ConnectorListenerRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectorListenerRuleMapOutput)
}

type ConnectorListenerRuleOutput struct{ *pulumi.OutputState }

func (ConnectorListenerRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ConnectorListenerRule)(nil)).Elem()
}

func (o ConnectorListenerRuleOutput) ToConnectorListenerRuleOutput() ConnectorListenerRuleOutput {
	return o
}

func (o ConnectorListenerRuleOutput) ToConnectorListenerRuleOutputWithContext(ctx context.Context) ConnectorListenerRuleOutput {
	return o
}

// The ID of the listener this rule is associated with.
func (o ConnectorListenerRuleOutput) ConnectorListenerId() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorListenerRule) pulumi.StringOutput { return v.ConnectorListenerId }).(pulumi.StringOutput)
}

// The rule to apply to the listener. It should be either the id of the resource or the name of the technology.
func (o ConnectorListenerRuleOutput) Rule() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorListenerRule) pulumi.StringOutput { return v.Rule }).(pulumi.StringOutput)
}

// If set to true, this connector listener rule cannot be deleted.
func (o ConnectorListenerRuleOutput) TerminationProtection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ConnectorListenerRule) pulumi.BoolPtrOutput { return v.TerminationProtection }).(pulumi.BoolPtrOutput)
}

// The type of the rule. It can be either `any`, `resource` or `technology`
func (o ConnectorListenerRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *ConnectorListenerRule) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type ConnectorListenerRuleArrayOutput struct{ *pulumi.OutputState }

func (ConnectorListenerRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ConnectorListenerRule)(nil)).Elem()
}

func (o ConnectorListenerRuleArrayOutput) ToConnectorListenerRuleArrayOutput() ConnectorListenerRuleArrayOutput {
	return o
}

func (o ConnectorListenerRuleArrayOutput) ToConnectorListenerRuleArrayOutputWithContext(ctx context.Context) ConnectorListenerRuleArrayOutput {
	return o
}

func (o ConnectorListenerRuleArrayOutput) Index(i pulumi.IntInput) ConnectorListenerRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ConnectorListenerRule {
		return vs[0].([]*ConnectorListenerRule)[vs[1].(int)]
	}).(ConnectorListenerRuleOutput)
}

type ConnectorListenerRuleMapOutput struct{ *pulumi.OutputState }

func (ConnectorListenerRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ConnectorListenerRule)(nil)).Elem()
}

func (o ConnectorListenerRuleMapOutput) ToConnectorListenerRuleMapOutput() ConnectorListenerRuleMapOutput {
	return o
}

func (o ConnectorListenerRuleMapOutput) ToConnectorListenerRuleMapOutputWithContext(ctx context.Context) ConnectorListenerRuleMapOutput {
	return o
}

func (o ConnectorListenerRuleMapOutput) MapIndex(k pulumi.StringInput) ConnectorListenerRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ConnectorListenerRule {
		return vs[0].(map[string]*ConnectorListenerRule)[vs[1].(string)]
	}).(ConnectorListenerRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorListenerRuleInput)(nil)).Elem(), &ConnectorListenerRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorListenerRuleArrayInput)(nil)).Elem(), ConnectorListenerRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectorListenerRuleMapInput)(nil)).Elem(), ConnectorListenerRuleMap{})
	pulumi.RegisterOutputType(ConnectorListenerRuleOutput{})
	pulumi.RegisterOutputType(ConnectorListenerRuleArrayOutput{})
	pulumi.RegisterOutputType(ConnectorListenerRuleMapOutput{})
}
