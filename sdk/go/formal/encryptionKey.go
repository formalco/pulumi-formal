// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package formal

import (
	"context"
	"reflect"

	"errors"
	"github.com/formalco/pulumi-formal/sdk/go/formal/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Registering an Encryption Key with Formal.
type EncryptionKey struct {
	pulumi.CustomResourceState

	// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
	Algorithm pulumi.StringOutput `pulumi:"algorithm"`
	// When the encryption key was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
	DecryptorUri pulumi.StringOutput `pulumi:"decryptorUri"`
	// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// The provider of the encryption key. Currently only 'aws' is supported.
	KeyProvider pulumi.StringOutput `pulumi:"keyProvider"`
	// Last update time.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewEncryptionKey registers a new resource with the given unique name, arguments, and options.
func NewEncryptionKey(ctx *pulumi.Context,
	name string, args *EncryptionKeyArgs, opts ...pulumi.ResourceOption) (*EncryptionKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Algorithm == nil {
		return nil, errors.New("invalid value for required argument 'Algorithm'")
	}
	if args.DecryptorUri == nil {
		return nil, errors.New("invalid value for required argument 'DecryptorUri'")
	}
	if args.KeyId == nil {
		return nil, errors.New("invalid value for required argument 'KeyId'")
	}
	if args.KeyProvider == nil {
		return nil, errors.New("invalid value for required argument 'KeyProvider'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource EncryptionKey
	err := ctx.RegisterResource("formal:index/encryptionKey:EncryptionKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetEncryptionKey gets an existing EncryptionKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetEncryptionKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *EncryptionKeyState, opts ...pulumi.ResourceOption) (*EncryptionKey, error) {
	var resource EncryptionKey
	err := ctx.ReadResource("formal:index/encryptionKey:EncryptionKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering EncryptionKey resources.
type encryptionKeyState struct {
	// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
	Algorithm *string `pulumi:"algorithm"`
	// When the encryption key was created.
	CreatedAt *string `pulumi:"createdAt"`
	// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
	DecryptorUri *string `pulumi:"decryptorUri"`
	// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
	KeyId *string `pulumi:"keyId"`
	// The provider of the encryption key. Currently only 'aws' is supported.
	KeyProvider *string `pulumi:"keyProvider"`
	// Last update time.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type EncryptionKeyState struct {
	// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
	Algorithm pulumi.StringPtrInput
	// When the encryption key was created.
	CreatedAt pulumi.StringPtrInput
	// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
	DecryptorUri pulumi.StringPtrInput
	// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
	KeyId pulumi.StringPtrInput
	// The provider of the encryption key. Currently only 'aws' is supported.
	KeyProvider pulumi.StringPtrInput
	// Last update time.
	UpdatedAt pulumi.StringPtrInput
}

func (EncryptionKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*encryptionKeyState)(nil)).Elem()
}

type encryptionKeyArgs struct {
	// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
	Algorithm string `pulumi:"algorithm"`
	// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
	DecryptorUri string `pulumi:"decryptorUri"`
	// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
	KeyId string `pulumi:"keyId"`
	// The provider of the encryption key. Currently only 'aws' is supported.
	KeyProvider string `pulumi:"keyProvider"`
}

// The set of arguments for constructing a EncryptionKey resource.
type EncryptionKeyArgs struct {
	// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
	Algorithm pulumi.StringInput
	// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
	DecryptorUri pulumi.StringInput
	// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
	KeyId pulumi.StringInput
	// The provider of the encryption key. Currently only 'aws' is supported.
	KeyProvider pulumi.StringInput
}

func (EncryptionKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*encryptionKeyArgs)(nil)).Elem()
}

type EncryptionKeyInput interface {
	pulumi.Input

	ToEncryptionKeyOutput() EncryptionKeyOutput
	ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput
}

func (*EncryptionKey) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKey)(nil)).Elem()
}

func (i *EncryptionKey) ToEncryptionKeyOutput() EncryptionKeyOutput {
	return i.ToEncryptionKeyOutputWithContext(context.Background())
}

func (i *EncryptionKey) ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyOutput)
}

// EncryptionKeyArrayInput is an input type that accepts EncryptionKeyArray and EncryptionKeyArrayOutput values.
// You can construct a concrete instance of `EncryptionKeyArrayInput` via:
//
//	EncryptionKeyArray{ EncryptionKeyArgs{...} }
type EncryptionKeyArrayInput interface {
	pulumi.Input

	ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput
	ToEncryptionKeyArrayOutputWithContext(context.Context) EncryptionKeyArrayOutput
}

type EncryptionKeyArray []EncryptionKeyInput

func (EncryptionKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EncryptionKey)(nil)).Elem()
}

func (i EncryptionKeyArray) ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput {
	return i.ToEncryptionKeyArrayOutputWithContext(context.Background())
}

func (i EncryptionKeyArray) ToEncryptionKeyArrayOutputWithContext(ctx context.Context) EncryptionKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyArrayOutput)
}

// EncryptionKeyMapInput is an input type that accepts EncryptionKeyMap and EncryptionKeyMapOutput values.
// You can construct a concrete instance of `EncryptionKeyMapInput` via:
//
//	EncryptionKeyMap{ "key": EncryptionKeyArgs{...} }
type EncryptionKeyMapInput interface {
	pulumi.Input

	ToEncryptionKeyMapOutput() EncryptionKeyMapOutput
	ToEncryptionKeyMapOutputWithContext(context.Context) EncryptionKeyMapOutput
}

type EncryptionKeyMap map[string]EncryptionKeyInput

func (EncryptionKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EncryptionKey)(nil)).Elem()
}

func (i EncryptionKeyMap) ToEncryptionKeyMapOutput() EncryptionKeyMapOutput {
	return i.ToEncryptionKeyMapOutputWithContext(context.Background())
}

func (i EncryptionKeyMap) ToEncryptionKeyMapOutputWithContext(ctx context.Context) EncryptionKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EncryptionKeyMapOutput)
}

type EncryptionKeyOutput struct{ *pulumi.OutputState }

func (EncryptionKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyOutput) ToEncryptionKeyOutput() EncryptionKeyOutput {
	return o
}

func (o EncryptionKeyOutput) ToEncryptionKeyOutputWithContext(ctx context.Context) EncryptionKeyOutput {
	return o
}

// The algorithm used for encryption. Can be either 'aes*random' or 'aes*deterministic'.
func (o EncryptionKeyOutput) Algorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.Algorithm }).(pulumi.StringOutput)
}

// When the encryption key was created.
func (o EncryptionKeyOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The URI of the decryptor (e.g., a URL to a Lambda function, either directly or via API Gateway). This is used to decrypt the data on the frontend only (and is never called by the Formal Control Plane backend).
func (o EncryptionKeyOutput) DecryptorUri() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.DecryptorUri }).(pulumi.StringOutput)
}

// The ID of the key in the provider's system (e.g., key ARN for AWS KMS).
func (o EncryptionKeyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// The provider of the encryption key. Currently only 'aws' is supported.
func (o EncryptionKeyOutput) KeyProvider() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.KeyProvider }).(pulumi.StringOutput)
}

// Last update time.
func (o EncryptionKeyOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *EncryptionKey) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type EncryptionKeyArrayOutput struct{ *pulumi.OutputState }

func (EncryptionKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyArrayOutput) ToEncryptionKeyArrayOutput() EncryptionKeyArrayOutput {
	return o
}

func (o EncryptionKeyArrayOutput) ToEncryptionKeyArrayOutputWithContext(ctx context.Context) EncryptionKeyArrayOutput {
	return o
}

func (o EncryptionKeyArrayOutput) Index(i pulumi.IntInput) EncryptionKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *EncryptionKey {
		return vs[0].([]*EncryptionKey)[vs[1].(int)]
	}).(EncryptionKeyOutput)
}

type EncryptionKeyMapOutput struct{ *pulumi.OutputState }

func (EncryptionKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EncryptionKey)(nil)).Elem()
}

func (o EncryptionKeyMapOutput) ToEncryptionKeyMapOutput() EncryptionKeyMapOutput {
	return o
}

func (o EncryptionKeyMapOutput) ToEncryptionKeyMapOutputWithContext(ctx context.Context) EncryptionKeyMapOutput {
	return o
}

func (o EncryptionKeyMapOutput) MapIndex(k pulumi.StringInput) EncryptionKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *EncryptionKey {
		return vs[0].(map[string]*EncryptionKey)[vs[1].(string)]
	}).(EncryptionKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyInput)(nil)).Elem(), &EncryptionKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyArrayInput)(nil)).Elem(), EncryptionKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EncryptionKeyMapInput)(nil)).Elem(), EncryptionKeyMap{})
	pulumi.RegisterOutputType(EncryptionKeyOutput{})
	pulumi.RegisterOutputType(EncryptionKeyArrayOutput{})
	pulumi.RegisterOutputType(EncryptionKeyMapOutput{})
}
