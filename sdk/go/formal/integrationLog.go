// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package formal

import (
	"context"
	"reflect"

	"github.com/formalco/pulumi-formal/sdk/go/formal/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Registering a Integration Logs app.
type IntegrationLog struct {
	pulumi.CustomResourceState

	// Configuration block for AWS S3 integration.
	AwsS3 IntegrationLogAwsS3PtrOutput `pulumi:"awsS3"`
	// Configuration block for Datadog integration.
	Datadog IntegrationLogDatadogPtrOutput `pulumi:"datadog"`
	// Friendly name for the Integration app.
	Name pulumi.StringOutput `pulumi:"name"`
	// Configuration block for Splunk integration.
	Splunk IntegrationLogSplunkPtrOutput `pulumi:"splunk"`
}

// NewIntegrationLog registers a new resource with the given unique name, arguments, and options.
func NewIntegrationLog(ctx *pulumi.Context,
	name string, args *IntegrationLogArgs, opts ...pulumi.ResourceOption) (*IntegrationLog, error) {
	if args == nil {
		args = &IntegrationLogArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IntegrationLog
	err := ctx.RegisterResource("formal:index/integrationLog:IntegrationLog", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIntegrationLog gets an existing IntegrationLog resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIntegrationLog(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IntegrationLogState, opts ...pulumi.ResourceOption) (*IntegrationLog, error) {
	var resource IntegrationLog
	err := ctx.ReadResource("formal:index/integrationLog:IntegrationLog", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IntegrationLog resources.
type integrationLogState struct {
	// Configuration block for AWS S3 integration.
	AwsS3 *IntegrationLogAwsS3 `pulumi:"awsS3"`
	// Configuration block for Datadog integration.
	Datadog *IntegrationLogDatadog `pulumi:"datadog"`
	// Friendly name for the Integration app.
	Name *string `pulumi:"name"`
	// Configuration block for Splunk integration.
	Splunk *IntegrationLogSplunk `pulumi:"splunk"`
}

type IntegrationLogState struct {
	// Configuration block for AWS S3 integration.
	AwsS3 IntegrationLogAwsS3PtrInput
	// Configuration block for Datadog integration.
	Datadog IntegrationLogDatadogPtrInput
	// Friendly name for the Integration app.
	Name pulumi.StringPtrInput
	// Configuration block for Splunk integration.
	Splunk IntegrationLogSplunkPtrInput
}

func (IntegrationLogState) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationLogState)(nil)).Elem()
}

type integrationLogArgs struct {
	// Configuration block for AWS S3 integration.
	AwsS3 *IntegrationLogAwsS3 `pulumi:"awsS3"`
	// Configuration block for Datadog integration.
	Datadog *IntegrationLogDatadog `pulumi:"datadog"`
	// Friendly name for the Integration app.
	Name *string `pulumi:"name"`
	// Configuration block for Splunk integration.
	Splunk *IntegrationLogSplunk `pulumi:"splunk"`
}

// The set of arguments for constructing a IntegrationLog resource.
type IntegrationLogArgs struct {
	// Configuration block for AWS S3 integration.
	AwsS3 IntegrationLogAwsS3PtrInput
	// Configuration block for Datadog integration.
	Datadog IntegrationLogDatadogPtrInput
	// Friendly name for the Integration app.
	Name pulumi.StringPtrInput
	// Configuration block for Splunk integration.
	Splunk IntegrationLogSplunkPtrInput
}

func (IntegrationLogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationLogArgs)(nil)).Elem()
}

type IntegrationLogInput interface {
	pulumi.Input

	ToIntegrationLogOutput() IntegrationLogOutput
	ToIntegrationLogOutputWithContext(ctx context.Context) IntegrationLogOutput
}

func (*IntegrationLog) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationLog)(nil)).Elem()
}

func (i *IntegrationLog) ToIntegrationLogOutput() IntegrationLogOutput {
	return i.ToIntegrationLogOutputWithContext(context.Background())
}

func (i *IntegrationLog) ToIntegrationLogOutputWithContext(ctx context.Context) IntegrationLogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationLogOutput)
}

// IntegrationLogArrayInput is an input type that accepts IntegrationLogArray and IntegrationLogArrayOutput values.
// You can construct a concrete instance of `IntegrationLogArrayInput` via:
//
//	IntegrationLogArray{ IntegrationLogArgs{...} }
type IntegrationLogArrayInput interface {
	pulumi.Input

	ToIntegrationLogArrayOutput() IntegrationLogArrayOutput
	ToIntegrationLogArrayOutputWithContext(context.Context) IntegrationLogArrayOutput
}

type IntegrationLogArray []IntegrationLogInput

func (IntegrationLogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationLog)(nil)).Elem()
}

func (i IntegrationLogArray) ToIntegrationLogArrayOutput() IntegrationLogArrayOutput {
	return i.ToIntegrationLogArrayOutputWithContext(context.Background())
}

func (i IntegrationLogArray) ToIntegrationLogArrayOutputWithContext(ctx context.Context) IntegrationLogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationLogArrayOutput)
}

// IntegrationLogMapInput is an input type that accepts IntegrationLogMap and IntegrationLogMapOutput values.
// You can construct a concrete instance of `IntegrationLogMapInput` via:
//
//	IntegrationLogMap{ "key": IntegrationLogArgs{...} }
type IntegrationLogMapInput interface {
	pulumi.Input

	ToIntegrationLogMapOutput() IntegrationLogMapOutput
	ToIntegrationLogMapOutputWithContext(context.Context) IntegrationLogMapOutput
}

type IntegrationLogMap map[string]IntegrationLogInput

func (IntegrationLogMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationLog)(nil)).Elem()
}

func (i IntegrationLogMap) ToIntegrationLogMapOutput() IntegrationLogMapOutput {
	return i.ToIntegrationLogMapOutputWithContext(context.Background())
}

func (i IntegrationLogMap) ToIntegrationLogMapOutputWithContext(ctx context.Context) IntegrationLogMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationLogMapOutput)
}

type IntegrationLogOutput struct{ *pulumi.OutputState }

func (IntegrationLogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationLog)(nil)).Elem()
}

func (o IntegrationLogOutput) ToIntegrationLogOutput() IntegrationLogOutput {
	return o
}

func (o IntegrationLogOutput) ToIntegrationLogOutputWithContext(ctx context.Context) IntegrationLogOutput {
	return o
}

// Configuration block for AWS S3 integration.
func (o IntegrationLogOutput) AwsS3() IntegrationLogAwsS3PtrOutput {
	return o.ApplyT(func(v *IntegrationLog) IntegrationLogAwsS3PtrOutput { return v.AwsS3 }).(IntegrationLogAwsS3PtrOutput)
}

// Configuration block for Datadog integration.
func (o IntegrationLogOutput) Datadog() IntegrationLogDatadogPtrOutput {
	return o.ApplyT(func(v *IntegrationLog) IntegrationLogDatadogPtrOutput { return v.Datadog }).(IntegrationLogDatadogPtrOutput)
}

// Friendly name for the Integration app.
func (o IntegrationLogOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *IntegrationLog) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Configuration block for Splunk integration.
func (o IntegrationLogOutput) Splunk() IntegrationLogSplunkPtrOutput {
	return o.ApplyT(func(v *IntegrationLog) IntegrationLogSplunkPtrOutput { return v.Splunk }).(IntegrationLogSplunkPtrOutput)
}

type IntegrationLogArrayOutput struct{ *pulumi.OutputState }

func (IntegrationLogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationLog)(nil)).Elem()
}

func (o IntegrationLogArrayOutput) ToIntegrationLogArrayOutput() IntegrationLogArrayOutput {
	return o
}

func (o IntegrationLogArrayOutput) ToIntegrationLogArrayOutputWithContext(ctx context.Context) IntegrationLogArrayOutput {
	return o
}

func (o IntegrationLogArrayOutput) Index(i pulumi.IntInput) IntegrationLogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IntegrationLog {
		return vs[0].([]*IntegrationLog)[vs[1].(int)]
	}).(IntegrationLogOutput)
}

type IntegrationLogMapOutput struct{ *pulumi.OutputState }

func (IntegrationLogMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationLog)(nil)).Elem()
}

func (o IntegrationLogMapOutput) ToIntegrationLogMapOutput() IntegrationLogMapOutput {
	return o
}

func (o IntegrationLogMapOutput) ToIntegrationLogMapOutputWithContext(ctx context.Context) IntegrationLogMapOutput {
	return o
}

func (o IntegrationLogMapOutput) MapIndex(k pulumi.StringInput) IntegrationLogOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IntegrationLog {
		return vs[0].(map[string]*IntegrationLog)[vs[1].(string)]
	}).(IntegrationLogOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationLogInput)(nil)).Elem(), &IntegrationLog{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationLogArrayInput)(nil)).Elem(), IntegrationLogArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationLogMapInput)(nil)).Elem(), IntegrationLogMap{})
	pulumi.RegisterOutputType(IntegrationLogOutput{})
	pulumi.RegisterOutputType(IntegrationLogArrayOutput{})
	pulumi.RegisterOutputType(IntegrationLogMapOutput{})
}
